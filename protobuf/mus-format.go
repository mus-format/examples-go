package main

import (
	"fmt"

	com "github.com/mus-format/common-go"
	"github.com/mus-format/mus-go"
	"github.com/mus-format/mus-go/unsafe"
	"github.com/mus-format/mus-go/varint"
	"google.golang.org/protobuf/encoding/protowire"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This file contains all the data related to the MUS format. Here you can find
// Marshal/Unmarshal/Size functions for:
// - DataV1.
// - DataV2.
// - timestamppb.Timestamp.
// - slice.
//
// In fact, when implementing Protobuf encoding with mus-go, we don't have to
// use the types generated by protoc, instead we can use a simple types, like
// this one:
// type DataV1 struct {
// 	 Str     string
//	 Bool bool
//   Int32   int32
//   Float64 float64
//   Slice []int32
//   Time    Timestamp
// }
//
// The content of this file should be generated and devided to:
// - data_v1.pb.mus.go
// - data_v2.pb.mus.go
// - timestamp.pb.mus.go
// - slice.pb.mus.go

// Protobuf tags of the DataV1 and DataV2 types.
var (
	strFieldTag     = protowire.EncodeTag(1, protowire.BytesType)
	boolFieldTag    = protowire.EncodeTag(2, protowire.VarintType)
	int32FieldTag   = protowire.EncodeTag(3, protowire.Fixed32Type)
	float64FieldTag = protowire.EncodeTag(4, protowire.Fixed64Type)
	sliceFieldTag   = protowire.EncodeTag(5, protowire.BytesType)
	timeFieldTag    = protowire.EncodeTag(6, protowire.BytesType)
)

// Protobuf uses int32 for the string length, so we need to define the
// corresponding Marshal/Unmarshal/Size functions.
var (
	lenM mus.MarshallerFn[int] = func(v int, bs []byte) (n int) {
		return varint.MarshalPositiveInt32(int32(v), bs)
	}
	lenU mus.UnmarshallerFn[int] = func(bs []byte) (v int, n int, err error) {
		v32, n, err := varint.UnmarshalPositiveInt32(bs)
		v = int(v32)
		return
	}
	lenS mus.SizerFn[int] = func(v int) (size int) {
		return varint.SizePositiveInt32(int32(v))
	}
)

// -----------------------------------------------------------------------------
// DataV1
// -----------------------------------------------------------------------------
// Actually, there is nothing complicated here, when marshalling a field (like
// data.Str or data.Bool) we:
// 1. Marshal the tag.
// 2. Marshal the length of the value, if the field is a struct or slice.
// 3. Marshal the value.
func MarshalDataV1Protobuf(data *DataV1, bs []byte) (n int) {
	if data.Str != "" {
		n += varint.MarshalUint64(strFieldTag, bs[n:])
		n += unsafe.MarshalString(data.Str, lenM, bs[n:])
	}
	if data.Bool {
		n += varint.MarshalUint64(boolFieldTag, bs[n:])
		n += unsafe.MarshalBool(data.Bool, bs[n:])
	}
	if data.Int32 != 0 {
		n += varint.MarshalUint64(int32FieldTag, bs[n:])
		n += unsafe.MarshalInt32(data.Int32, bs[n:])
	}
	if data.Float64 != 0 {
		n += varint.MarshalUint64(float64FieldTag, bs[n:])
		n += unsafe.MarshalFloat64(data.Float64, bs[n:])
	}
	if len(data.Slice) > 0 {
		n += varint.MarshalUint64(sliceFieldTag, bs[n:])
		n += MarshalSliceProtobuf[int32](data.Slice,
			mus.MarshallerFn[int32](varint.MarshalInt32),
			mus.SizerFn[int32](varint.SizeInt32),
			bs[n:])
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		n += varint.MarshalUint64(timeFieldTag, bs[n:])
		n += varint.MarshalPositiveInt(SizeTimestampProtobuf(data.Time), bs[n:])
		n += MarshalTimestampNative(data.Time, bs[n:])
	}
	return
}

// Here we unmarshal fields in the loop:
// 1. Unmarshal the tag.
// 2. Unmarshal the length of the value, if the field is a struct or slice.
// 3. Unmarshal the value.
func UnmarshalDataV1Protobuf(bs []byte) (data *DataV1, n int, err error) {
	var (
		n1  int
		l   = len(bs)
		tag uint64
		sl  []int32
	)
	data = &DataV1{}
	for n < l {
		tag, n1, err = varint.UnmarshalUint64(bs[n:])
		n += n1
		if err != nil {
			return
		}
		switch tag {
		case strFieldTag:
			data.Str, n1, err = unsafe.UnmarshalString(lenU, bs[n:])
		case boolFieldTag:
			data.Bool, n1, err = unsafe.UnmarshalBool(bs[n:])
		case int32FieldTag:
			data.Int32, n1, err = unsafe.UnmarshalInt32(bs[n:])
		case float64FieldTag:
			data.Float64, n1, err = unsafe.UnmarshalFloat64(bs[n:])
		case sliceFieldTag:
			sl, n1, err = UnmarshalSliceProtobuf[int32](
				mus.UnmarshallerFn[int32](varint.UnmarshalInt32), bs[n:])
			data.Slice = append(data.Slice, sl...)
		case timeFieldTag:
			n1, err = varint.SkipPositiveInt(bs[n:])
			n += n1
			if err != nil {
				return
			}
			data.Time, n1, err = UnmarshalTimestampNative(bs[n:])
		default:
			err = fmt.Errorf("unexpected tag %v", tag)
		}
		n += n1
		if err != nil {
			return
		}
	}
	return
}

func SizeDataV1Protobuf(data *DataV1) (size int) {
	if data.Str != "" {
		size += varint.SizeUint64(strFieldTag)
		size += unsafe.SizeString(data.Str, lenS)
	}
	if data.Bool {
		size += varint.SizeUint64(boolFieldTag)
		size += unsafe.SizeBool(data.Bool)
	}
	if data.Int32 != 0 {
		size += varint.SizeUint64(int32FieldTag)
		size += unsafe.SizeInt32(data.Int32)
	}
	if data.Float64 != 0 {
		size += varint.SizeUint64(float64FieldTag)
		size += unsafe.SizeFloat64(data.Float64)
	}
	if len(data.Slice) > 0 {
		size += varint.SizeUint64(sliceFieldTag)
		size += SizeSliceProtobuf[int32](data.Slice,
			mus.SizerFn[int32](varint.SizeInt32))
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		sizeTimestamp := SizeTimestampProtobuf(data.Time)
		size += varint.SizeUint64(timeFieldTag)
		size += varint.SizePositiveInt(sizeTimestamp)
		size += sizeTimestamp
	}
	return
}

// -----------------------------------------------------------------------------
// DataV2
// -----------------------------------------------------------------------------
func MarshalDataV2Protobuf(data *DataV2, bs []byte) (n int) {
	if data.Str != "" {
		n += varint.MarshalUint64(strFieldTag, bs[n:])
		n += unsafe.MarshalString(data.Str, lenM, bs[n:])
	}
	if data.Int32 != 0 {
		n += varint.MarshalUint64(int32FieldTag, bs[n:])
		n += unsafe.MarshalInt32(data.Int32, bs[n:])
	}
	if data.Float64 != 0 {
		n += varint.MarshalUint64(float64FieldTag, bs[n:])
		n += unsafe.MarshalFloat64(data.Float64, bs[n:])
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		n += varint.MarshalUint64(timeFieldTag, bs[n:])
		n += varint.MarshalPositiveInt(SizeTimestampProtobuf(data.Time), bs[n:])
		n += MarshalTimestampNative(data.Time, bs[n:])
	}
	return
}

func UnmarshalDataV2Protobuf(bs []byte) (data *DataV2, n int, err error) {
	var (
		n1  int
		l   = len(bs)
		tag uint64
	)
	data = &DataV2{}
	for n < l {
		tag, n1, err = varint.UnmarshalUint64(bs[n:])
		n += n1
		if err != nil {
			return
		}
		switch tag {
		case strFieldTag:
			data.Str, n1, err = unsafe.UnmarshalString(lenU, bs[n:])
		case boolFieldTag:
			// Bool field was removed in DataV2, so simply skip it here.
			n1, err = unsafe.SkipBool(bs[n:])
		case int32FieldTag:
			data.Int32, n1, err = unsafe.UnmarshalInt32(bs[n:])
		case float64FieldTag:
			data.Float64, n1, err = unsafe.UnmarshalFloat64(bs[n:])
		case sliceFieldTag:
			// Slice field was remove in DataV2, so simply skip it here.
			n1, err = SkipSliceProtobuf(bs[n:])
		case timeFieldTag:
			n1, err = varint.SkipPositiveInt(bs[n:])
			n += n1
			if err != nil {
				return
			}
			data.Time, n1, err = UnmarshalTimestampNative(bs[n:])
		default:
			err = fmt.Errorf("unexpected tag %v", tag)
		}
		n += n1
		if err != nil {
			return
		}
	}
	return
}

func SizeDataV2Protobuf(data *DataV2) (size int) {
	if data.Str != "" {
		size += varint.SizeUint64(strFieldTag)
		size += unsafe.SizeString(data.Str, lenS)
	}
	if data.Int32 != 0 {
		size += varint.SizeUint64(int32FieldTag)
		size += unsafe.SizeInt32(data.Int32)
	}
	if data.Float64 != 0 {
		size += varint.SizeUint64(float64FieldTag)
		size += unsafe.SizeFloat64(data.Float64)
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		sizeTimestamp := SizeTimestampProtobuf(data.Time)
		size += varint.SizeUint64(timeFieldTag)
		size += varint.SizePositiveInt(sizeTimestamp)
		size += sizeTimestamp
	}
	return
}

// -----------------------------------------------------------------------------
// timestamppb.Timestamp
// -----------------------------------------------------------------------------
var (
	secondsFieldTag = protowire.EncodeTag(1, protowire.VarintType)
	nanosFieldTag   = protowire.EncodeTag(2, protowire.VarintType)
)

func MarshalTimestampNative(tm *timestamppb.Timestamp, bs []byte) (n int) {
	if tm.Seconds != 0 {
		n += varint.MarshalUint64(secondsFieldTag, bs[n:])
		n += varint.MarshalPositiveInt64(tm.Seconds, bs[n:])
	}
	if tm.Nanos != 0 {
		n += varint.MarshalUint64(nanosFieldTag, bs[n:])
		n += varint.MarshalPositiveInt32(tm.Nanos, bs[n:])
	}
	return
}

func UnmarshalTimestampNative(bs []byte) (tm *timestamppb.Timestamp, n int,
	err error) {
	var (
		n1  int
		l   = len(bs)
		tag uint64
	)
	tm = &timestamppb.Timestamp{}
	for {
		tag, n1, err = varint.UnmarshalUint64(bs[n:])
		n += n1
		if err != nil {
			return
		}
		switch tag {
		case secondsFieldTag:
			tm.Seconds, n1, err = varint.UnmarshalPositiveInt64(bs[n:])
		case nanosFieldTag:
			tm.Nanos, n1, err = varint.UnmarshalPositiveInt32(bs[n:])
		}
		n += n1
		if err != nil {
			return
		}
		if n == l {
			return
		}
	}
}

func SizeTimestampProtobuf(tm *timestamppb.Timestamp) (size int) {
	if tm.Seconds != 0 {
		size += varint.SizeUint64(secondsFieldTag)
		size += varint.SizePositiveInt64(tm.Seconds)
	}
	if tm.Nanos != 0 {
		size += varint.SizeUint64(nanosFieldTag)
		size += varint.SizePositiveInt32(tm.Nanos)
	}
	return
}

// -----------------------------------------------------------------------------
// Slice
// -----------------------------------------------------------------------------
func MarshalSliceProtobuf[T any](sl []T, m mus.Marshaller[T], s mus.Sizer[T],
	bs []byte) (n int) {
	n = varint.MarshalPositiveInt(sliceLEN(sl, s), bs)
	for i := 0; i < len(sl); i++ {
		n += m.MarshalMUS(sl[i], bs[n:])
	}
	return
}

func UnmarshalSliceProtobuf[T any](u mus.Unmarshaller[T], bs []byte) (sl []T,
	n int, err error) {
	var (
		n1   int
		elem T
	)
	sl = []T{}
	l, n, err := varint.UnmarshalPositiveInt(bs)
	if err != nil {
		return
	}
	l = l + n
	if len(bs) < l {
		err = com.ErrOverflow
		return
	}
	for n < l {
		elem, n1, err = u.UnmarshalMUS(bs[n:])
		n += n1
		if err != nil {
			return
		}
		sl = append(sl, elem)
	}
	return
}

func SizeSliceProtobuf[T any](sl []T, s mus.Sizer[T]) (size int) {
	l := sliceLEN(sl, s)
	return varint.SizePositiveInt(l) + l
}

func SkipSliceProtobuf(bs []byte) (n int, err error) {
	l, n, err := varint.UnmarshalPositiveInt(bs)
	if err != nil {
		return
	}
	n = n + l
	if len(bs) < n {
		err = com.ErrOverflow
		return
	}
	return
}

func sliceLEN[T any](sl []T, s mus.Sizer[T]) (size int) {
	for i := 0; i < len(sl); i++ {
		size += s.SizeMUS(sl[i])
	}
	return
}
