package main

import (
	"fmt"

	com "github.com/mus-format/common-go"
	"github.com/mus-format/mus-go"
	"github.com/mus-format/mus-go/unsafe"
	"github.com/mus-format/mus-go/varint"
	"google.golang.org/protobuf/encoding/protowire"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This file contains all the data related to the MUS format. Here you can find
// Marshal/Unmarshal/Size functions for:
// - DataV1.
// - DataV2.
// - timestamppb.Timestamp.
// - slice.
//
// In fact, when implementing Protobuf encoding with mus-go, there is no need
// for types generated by protoc. It is enough to use simple types like this
// one:"
// type DataV1 struct {
// 	 Str     string
//	 Bool bool
//   Int32   int32
//   Float64 float64
//   Slice []int32
//   Time    Timestamp
// }
//
// The content of this file should be generated.

// Protobuf tags of the DataV1 and DataV2 types.
var (
	strFieldTag     = protowire.EncodeTag(1, protowire.BytesType)
	boolFieldTag    = protowire.EncodeTag(2, protowire.VarintType)
	int32FieldTag   = protowire.EncodeTag(3, protowire.Fixed32Type)
	float64FieldTag = protowire.EncodeTag(4, protowire.Fixed64Type)
	sliceFieldTag   = protowire.EncodeTag(5, protowire.BytesType)
	timeFieldTag    = protowire.EncodeTag(6, protowire.BytesType)
)

// Protobuf uses int32 for the string length, so we need to define the
// corresponding Marshal/Unmarshal/Size functions.
var (
	lenM mus.MarshallerFn[int] = func(v int, bs []byte) (n int) {
		return varint.MarshalPositiveInt32(int32(v), bs)
	}
	lenU mus.UnmarshallerFn[int] = func(bs []byte) (v int, n int, err error) {
		v32, n, err := varint.UnmarshalPositiveInt32(bs)
		v = int(v32)
		return
	}
	lenS mus.SizerFn[int] = func(v int) (size int) {
		return varint.SizePositiveInt32(int32(v))
	}
)

// -----------------------------------------------------------------------------
// DataV1
// -----------------------------------------------------------------------------

// MarshalDataV1Protobuf marshals data using Protobuf encoding. Actually, there
// is nothing complicated here. For each field (like data.Str or data.Bool) it:
// 1. Marshals the tag.
// 2. Marshals the length of the value, if the field is a struct or slice.
// 3. Marshals the value.
func MarshalDataV1Protobuf(data *DataV1, bs []byte) (n int) {
	if data.Str != "" {
		n += varint.MarshalUint64(strFieldTag, bs[n:])
		n += unsafe.MarshalString(data.Str, lenM, bs[n:])
	}
	if data.Bool {
		n += varint.MarshalUint64(boolFieldTag, bs[n:])
		n += unsafe.MarshalBool(data.Bool, bs[n:])
	}
	if data.Int32 != 0 {
		n += varint.MarshalUint64(int32FieldTag, bs[n:])
		n += unsafe.MarshalInt32(data.Int32, bs[n:])
	}
	if data.Float64 != 0 {
		n += varint.MarshalUint64(float64FieldTag, bs[n:])
		n += unsafe.MarshalFloat64(data.Float64, bs[n:])
	}
	if len(data.Slice) > 0 {
		n += varint.MarshalUint64(sliceFieldTag, bs[n:])
		n += varint.MarshalPositiveInt(
			SizeSliceProtobuf[int32](data.Slice, mus.SizerFn[int32](varint.SizeInt32)), bs[n:],
		)
		n += MarshalSliceProtobuf[int32](data.Slice,
			mus.MarshallerFn[int32](varint.MarshalInt32), bs[n:])
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		n += varint.MarshalUint64(timeFieldTag, bs[n:])
		n += varint.MarshalPositiveInt(SizeTimestampProtobuf(data.Time), bs[n:])
		n += MarshalTimestampProtobuf(data.Time, bs[n:])
	}
	return
}

// UnmarshalDataV1Protobuf unmarshals fields in Ð° loop that:
// 1. Unmarshals the tag.
// 2. Unmarshals the length of the value, if the field is a struct or slice.
// 3. Unmarshals the value.
func UnmarshalDataV1Protobuf(bs []byte) (data *DataV1, n int, err error) {
	var (
		n1       int
		l        = len(bs)
		tag      uint64
		slice    []int32
		sliceLen int
	)
	data = &DataV1{}
	for n < l {
		tag, n1, err = varint.UnmarshalUint64(bs[n:])
		n += n1
		if err != nil {
			return
		}
		switch tag {
		case strFieldTag:
			data.Str, n1, err = unsafe.UnmarshalString(lenU, bs[n:])
		case boolFieldTag:
			data.Bool, n1, err = unsafe.UnmarshalBool(bs[n:])
		case int32FieldTag:
			data.Int32, n1, err = unsafe.UnmarshalInt32(bs[n:])
		case float64FieldTag:
			data.Float64, n1, err = unsafe.UnmarshalFloat64(bs[n:])
		case sliceFieldTag:
			sliceLen, n1, err = varint.UnmarshalPositiveInt(bs[n:])
			n += n1
			if err != nil {
				return
			}
			slice, n1, err = UnmarshalSliceProtobuf[int32](sliceLen,
				mus.UnmarshallerFn[int32](varint.UnmarshalInt32), bs[n:])
			data.Slice = append(data.Slice, slice...)
		case timeFieldTag:
			n1, err = varint.SkipPositiveInt(bs[n:])
			n += n1
			if err != nil {
				return
			}
			data.Time, n1, err = UnmarshalTimestampProtobuf(bs[n:])
		default:
			err = fmt.Errorf("unexpected tag %v", tag)
		}
		n += n1
		if err != nil {
			return
		}
	}
	return
}

func SizeDataV1Protobuf(data *DataV1) (size int) {
	if data.Str != "" {
		size += varint.SizeUint64(strFieldTag)
		size += unsafe.SizeString(data.Str, lenS)
	}
	if data.Bool {
		size += varint.SizeUint64(boolFieldTag)
		size += unsafe.SizeBool(data.Bool)
	}
	if data.Int32 != 0 {
		size += varint.SizeUint64(int32FieldTag)
		size += unsafe.SizeInt32(data.Int32)
	}
	if data.Float64 != 0 {
		size += varint.SizeUint64(float64FieldTag)
		size += unsafe.SizeFloat64(data.Float64)
	}
	if len(data.Slice) > 0 {
		sizeSlice := SizeSliceProtobuf[int32](data.Slice, mus.SizerFn[int32](varint.SizeInt32))
		size += varint.SizeUint64(sliceFieldTag)
		size += varint.SizePositiveInt(sizeSlice)
		size += sizeSlice
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		sizeTimestamp := SizeTimestampProtobuf(data.Time)
		size += varint.SizeUint64(timeFieldTag)
		size += varint.SizePositiveInt(sizeTimestamp)
		size += sizeTimestamp
	}
	return
}

// -----------------------------------------------------------------------------
// DataV2
// -----------------------------------------------------------------------------

func MarshalDataV2Protobuf(data *DataV2, bs []byte) (n int) {
	if data.Str != "" {
		n += varint.MarshalUint64(strFieldTag, bs[n:])
		n += unsafe.MarshalString(data.Str, lenM, bs[n:])
	}
	if data.Int32 != 0 {
		n += varint.MarshalUint64(int32FieldTag, bs[n:])
		n += unsafe.MarshalInt32(data.Int32, bs[n:])
	}
	if data.Float64 != 0 {
		n += varint.MarshalUint64(float64FieldTag, bs[n:])
		n += unsafe.MarshalFloat64(data.Float64, bs[n:])
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		n += varint.MarshalUint64(timeFieldTag, bs[n:])
		n += varint.MarshalPositiveInt(SizeTimestampProtobuf(data.Time), bs[n:])
		n += MarshalTimestampProtobuf(data.Time, bs[n:])
	}
	return
}

func UnmarshalDataV2Protobuf(bs []byte) (data *DataV2, n int, err error) {
	var (
		n1  int
		l   = len(bs)
		tag uint64
	)
	data = &DataV2{}
	for n < l {
		tag, n1, err = varint.UnmarshalUint64(bs[n:])
		n += n1
		if err != nil {
			return
		}
		switch tag {
		case strFieldTag:
			data.Str, n1, err = unsafe.UnmarshalString(lenU, bs[n:])
		case boolFieldTag:
			// Bool field was removed in DataV2, so simply skip it here.
			n1, err = unsafe.SkipBool(bs[n:])
		case int32FieldTag:
			data.Int32, n1, err = unsafe.UnmarshalInt32(bs[n:])
		case float64FieldTag:
			data.Float64, n1, err = unsafe.UnmarshalFloat64(bs[n:])
		case sliceFieldTag:
			// Slice field was remove in DataV2, so simply skip it here.
			n1, err = SkipLenFieldProtobuf(bs[n:])
		case timeFieldTag:
			n1, err = varint.SkipPositiveInt(bs[n:])
			n += n1
			if err != nil {
				return
			}
			data.Time, n1, err = UnmarshalTimestampProtobuf(bs[n:])
		default:
			err = fmt.Errorf("unexpected tag %v", tag)
		}
		n += n1
		if err != nil {
			return
		}
	}
	return
}

func SizeDataV2Protobuf(data *DataV2) (size int) {
	if data.Str != "" {
		size += varint.SizeUint64(strFieldTag)
		size += unsafe.SizeString(data.Str, lenS)
	}
	if data.Int32 != 0 {
		size += varint.SizeUint64(int32FieldTag)
		size += unsafe.SizeInt32(data.Int32)
	}
	if data.Float64 != 0 {
		size += varint.SizeUint64(float64FieldTag)
		size += unsafe.SizeFloat64(data.Float64)
	}
	if data.Time != nil && (data.Time.Seconds != 0 || data.Time.Nanos != 0) {
		sizeTimestamp := SizeTimestampProtobuf(data.Time)
		size += varint.SizeUint64(timeFieldTag)
		size += varint.SizePositiveInt(sizeTimestamp)
		size += sizeTimestamp
	}
	return
}

// -----------------------------------------------------------------------------
// timestamppb.Timestamp
// -----------------------------------------------------------------------------

var (
	secondsFieldTag = protowire.EncodeTag(1, protowire.VarintType)
	nanosFieldTag   = protowire.EncodeTag(2, protowire.VarintType)
)

func MarshalTimestampProtobuf(tm *timestamppb.Timestamp, bs []byte) (n int) {
	if tm.Seconds != 0 {
		n += varint.MarshalUint64(secondsFieldTag, bs[n:])
		n += varint.MarshalPositiveInt64(tm.Seconds, bs[n:])
	}
	if tm.Nanos != 0 {
		n += varint.MarshalUint64(nanosFieldTag, bs[n:])
		n += varint.MarshalPositiveInt32(tm.Nanos, bs[n:])
	}
	return
}

func UnmarshalTimestampProtobuf(bs []byte) (tm *timestamppb.Timestamp, n int,
	err error) {
	var (
		n1  int
		l   = len(bs)
		tag uint64
	)
	tm = &timestamppb.Timestamp{}
	for {
		tag, n1, err = varint.UnmarshalUint64(bs[n:])
		n += n1
		if err != nil {
			return
		}
		switch tag {
		case secondsFieldTag:
			tm.Seconds, n1, err = varint.UnmarshalPositiveInt64(bs[n:])
		case nanosFieldTag:
			tm.Nanos, n1, err = varint.UnmarshalPositiveInt32(bs[n:])
		}
		n += n1
		if err != nil {
			return
		}
		if n == l {
			return
		}
	}
}

func SizeTimestampProtobuf(tm *timestamppb.Timestamp) (size int) {
	if tm.Seconds != 0 {
		size += varint.SizeUint64(secondsFieldTag)
		size += varint.SizePositiveInt64(tm.Seconds)
	}
	if tm.Nanos != 0 {
		size += varint.SizeUint64(nanosFieldTag)
		size += varint.SizePositiveInt32(tm.Nanos)
	}
	return
}

// -----------------------------------------------------------------------------
// Slice
// -----------------------------------------------------------------------------

func MarshalSliceProtobuf[T any](sl []T, m mus.Marshaller[T], bs []byte) (n int) {
	for i := 0; i < len(sl); i++ {
		n += m.Marshal(sl[i], bs[n:])
	}
	return
}

func UnmarshalSliceProtobuf[T any](length int, u mus.Unmarshaller[T],
	bs []byte) (sl []T, n int, err error) {
	var (
		n1   int
		elem T
	)
	sl = []T{}
	if len(bs) < length {
		err = com.ErrOverflow
		return
	}
	for n < length {
		elem, n1, err = u.Unmarshal(bs[n:])
		n += n1
		if err != nil {
			return
		}
		sl = append(sl, elem)
	}
	return
}

func SizeSliceProtobuf[T any](sl []T, s mus.Sizer[T]) (size int) {
	for i := 0; i < len(sl); i++ {
		size += s.Size(sl[i])
	}
	return
}

// -----------------------------------------------------------------------------
// General
// -----------------------------------------------------------------------------

func SkipLenFieldProtobuf(bs []byte) (n int, err error) {
	l, n, err := varint.UnmarshalPositiveInt(bs)
	if err != nil {
		return
	}
	n = n + l
	if len(bs) < n {
		err = com.ErrOverflow
		return
	}
	return
}
